<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Karlscraft - Minecraft Koordinaten Karte (Vincenty)</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #2c3e50;
        }
        
        #map {
            height: 100vh;
            width: 100%;
            cursor: crosshair;
        }
        
        .info-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
            max-width: 350px;
            font-size: 14px;
        }
        
        .info-panel h2 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 20px;
            border-bottom: 2px solid #3498db;
            padding-bottom: 8px;
        }
        
        .info-panel p {
            margin: 8px 0;
            line-height: 1.6;
        }
        
        .info-panel strong {
            color: #2c3e50;
            display: inline-block;
            min-width: 140px;
        }
        
        .minecraft-coords {
            background: #27ae60;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-top: 12px;
            font-family: 'Courier New', monospace;
            font-weight: bold;
        }
        
        .real-coords {
            background: #3498db;
            color: white;
            padding: 12px;
            border-radius: 6px;
            margin-top: 8px;
        }
        
        .warning {
            background: #e74c3c;
            color: white;
            padding: 10px;
            border-radius: 6px;
            margin-top: 10px;
            font-weight: bold;
        }
        
        .layer-control {
            position: absolute;
            top: 20px;
            left: 60px;
            background: rgba(255, 255, 255, 0.95);
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        
        .layer-control h3 {
            margin-bottom: 10px;
            font-size: 16px;
            color: #2c3e50;
        }
        
        .layer-control label {
            display: block;
            margin: 8px 0;
            cursor: pointer;
            color: #2c3e50;
        }
        
        .layer-control input {
            margin-right: 8px;
            cursor: pointer;
        }

        .elevation-loading {
            color: #95a5a6;
            font-style: italic;
        }

        .y-limit-exceeded {
            color: #e74c3c;
            font-weight: bold;
        }

        .accuracy-badge {
            background: #9b59b6;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 11px;
            display: inline-block;
            margin-top: 10px;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    
    <div class="layer-control">
        <h3>üó∫Ô∏è Kartenebenen</h3>
        <label>
            <input type="radio" name="layer" value="osm" checked>
            OpenStreetMap
        </label>
        <label>
            <input type="radio" name="layer" value="topo">
            OpenTopoMap
        </label>
        <label>
            <input type="radio" name="layer" value="railway">
            OpenRailwayMap
        </label>
    </div>
    
    <div class="info-panel" id="infoPanel">
        <h2>üéÆ Karlscraft Koordinaten</h2>
        <p>Klicke auf die Karte, um Minecraft-Koordinaten zu erhalten!</p>
        <p style="margin-top: 15px; color: #7f8c8d; font-size: 12px;">
            <strong>Nullpunkt:</strong> Pyramide am Marktplatz<br>
            <strong>Rotation:</strong> 4¬∞ f√ºr gerade Kaiserstra√üe<br>
            <strong>Ma√üstab:</strong> 1:1
        </p>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        // Nullpunkt: Pyramide am Marktplatz
        const ORIGIN_LAT = 49.00923;
        const ORIGIN_LON = 8.4039;
        const ORIGIN_ELEVATION = 115; // Meter √ºber NN
        const MINECRAFT_Y_ORIGIN = 64;
        const ROTATION_ANGLE = 4; // Grad Neigung f√ºr gerade Kaiserstra√üe
        
        // WGS84 Ellipsoid-Parameter
        const WGS84_A = 6378137.0; // Gro√üe Halbachse in Metern
        const WGS84_B = 6356752.314245; // Kleine Halbachse in Metern
        const WGS84_F = 1 / 298.257223563; // Abplattung
        
        // Initialisiere Karte
        const map = L.map('map').setView([ORIGIN_LAT, ORIGIN_LON], 15);
        
        // Layer definieren
        const osmLayer = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenStreetMap contributors',
            maxZoom: 19
        });
        
        const topoLayer = L.tileLayer('https://{s}.tile.opentopomap.org/{z}/{x}/{y}.png', {
            attribution: '¬© OpenTopoMap contributors',
            maxZoom: 17
        });
        
        const railwayLayer = L.tileLayer('https://{s}.tiles.openrailwaymap.org/standard/{z}/{x}/{y}.png', {
            attribution: '¬© OpenRailwayMap contributors',
            maxZoom: 19
        });
        
        // Standardlayer hinzuf√ºgen
        osmLayer.addTo(map);
        let currentLayer = osmLayer;
        
        // Layer-Steuerung
        document.querySelectorAll('input[name="layer"]').forEach(radio => {
            radio.addEventListener('change', (e) => {
                map.removeLayer(currentLayer);
                switch(e.target.value) {
                    case 'osm':
                        currentLayer = osmLayer;
                        break;
                    case 'topo':
                        currentLayer = topoLayer;
                        break;
                    case 'railway':
                        currentLayer = railwayLayer;
                        break;
                }
                currentLayer.addTo(map);
            });
        });
        
        // Marker f√ºr Nullpunkt
        const originMarker = L.marker([ORIGIN_LAT, ORIGIN_LON], {
            icon: L.divIcon({
                className: 'origin-marker',
                html: 'üî∫',
                iconSize: [30, 30],
                iconAnchor: [7, 7]
            })
        }).addTo(map);
        originMarker.bindPopup('<strong>Nullpunkt</strong><br>Pyramide am Marktplatz<br>MC: X:0, Y:64, Z:0');
        
        // Aktueller Marker
        let currentMarker = null;
        
        // Vincenty-Formel: Direkte Methode (Forward)
        // Berechnet Distanz und initialen Richtungswinkel zwischen zwei Punkten
        function vincentyInverse(lat1, lon1, lat2, lon2) {
            const a = WGS84_A;
            const b = WGS84_B;
            const f = WGS84_F;
            
            const L = (lon2 - lon1) * Math.PI / 180;
            const U1 = Math.atan((1 - f) * Math.tan(lat1 * Math.PI / 180));
            const U2 = Math.atan((1 - f) * Math.tan(lat2 * Math.PI / 180));
            const sinU1 = Math.sin(U1);
            const cosU1 = Math.cos(U1);
            const sinU2 = Math.sin(U2);
            const cosU2 = Math.cos(U2);
            
            let lambda = L;
            let lambdaP;
            let iterLimit = 100;
            let cosSqAlpha, sinSigma, cos2SigmaM, cosSigma, sigma;
            
            do {
                const sinLambda = Math.sin(lambda);
                const cosLambda = Math.cos(lambda);
                sinSigma = Math.sqrt((cosU2 * sinLambda) * (cosU2 * sinLambda) +
                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda) * 
                    (cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
                
                if (sinSigma === 0) {
                    return { distance: 0, bearing: 0 };
                }
                
                cosSigma = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
                sigma = Math.atan2(sinSigma, cosSigma);
                const sinAlpha = cosU1 * cosU2 * sinLambda / sinSigma;
                cosSqAlpha = 1 - sinAlpha * sinAlpha;
                cos2SigmaM = cosSigma - 2 * sinU1 * sinU2 / cosSqAlpha;
                
                if (isNaN(cos2SigmaM)) {
                    cos2SigmaM = 0;
                }
                
                const C = f / 16 * cosSqAlpha * (4 + f * (4 - 3 * cosSqAlpha));
                lambdaP = lambda;
                lambda = L + (1 - C) * f * sinAlpha *
                    (sigma + C * sinSigma * (cos2SigmaM + C * cosSigma * 
                    (-1 + 2 * cos2SigmaM * cos2SigmaM)));
                    
            } while (Math.abs(lambda - lambdaP) > 1e-12 && --iterLimit > 0);
            
            if (iterLimit === 0) {
                return null;
            }
            
            const uSq = cosSqAlpha * (a * a - b * b) / (b * b);
            const A = 1 + uSq / 16384 * (4096 + uSq * (-768 + uSq * (320 - 175 * uSq)));
            const B = uSq / 1024 * (256 + uSq * (-128 + uSq * (74 - 47 * uSq)));
            const deltaSigma = B * sinSigma * (cos2SigmaM + B / 4 * 
                (cosSigma * (-1 + 2 * cos2SigmaM * cos2SigmaM) -
                B / 6 * cos2SigmaM * (-3 + 4 * sinSigma * sinSigma) * 
                (-3 + 4 * cos2SigmaM * cos2SigmaM)));
            
            const distance = b * A * (sigma - deltaSigma);
            
            // Initialer Richtungswinkel
            const bearing = Math.atan2(cosU2 * Math.sin(lambda),
                cosU1 * sinU2 - sinU1 * cosU2 * Math.cos(lambda));
            
            return {
                distance: distance,
                bearing: (bearing * 180 / Math.PI + 360) % 360
            };
        }
        
        // Funktion: H√∂he von Open-Elevation API abrufen
        async function getElevation(lat, lon) {
            try {
                const response = await fetch(`https://api.open-elevation.com/api/v1/lookup?locations=${lat},${lon}`);
                const data = await response.json();
                if (data.results && data.results.length > 0) {
                    return data.results[0].elevation;
                }
            } catch (error) {
                console.error('Fehler beim Abrufen der H√∂he:', error);
            }
            return null;
        }
        
        // Funktion: Koordinaten zu Minecraft umrechnen (mit Vincenty)
        async function convertToMinecraft(lat, lon) {
            // Vincenty-Berechnung f√ºr Distanz und Richtung
            const result = vincentyInverse(ORIGIN_LAT, ORIGIN_LON, lat, lon);
            
            if (!result) {
                console.error('Vincenty-Berechnung fehlgeschlagen');
                return null;
            }
            
            const distance = result.distance; // in Metern
            const bearing = result.bearing; // in Grad
            
            // Rotation um 4¬∞ anwenden (damit Kaiserstra√üe gerade wird)
            const adjustedBearing = (bearing - ROTATION_ANGLE + 360) % 360;
            
            // In Minecraft-Koordinaten umrechnen
            // Norden = 0¬∞, Osten = 90¬∞, S√ºden = 180¬∞, Westen = 270¬∞
            // In Minecraft: +X = Osten, -X = Westen, -Z = Norden, +Z = S√ºden
            const angleRad = adjustedBearing * Math.PI / 180;
            
            const minecraftX = Math.round(distance * Math.sin(angleRad));
            const minecraftZ = Math.round(-distance * Math.cos(angleRad));
            
            // H√∂he abrufen
            const elevation = await getElevation(lat, lon);
            let minecraftY = null;
            if (elevation !== null) {
                minecraftY = Math.round(MINECRAFT_Y_ORIGIN + (elevation - ORIGIN_ELEVATION));
            }
            
            return {
                x: minecraftX,
                y: minecraftY,
                z: minecraftZ,
                elevation: elevation,
                distance: distance
            };
        }
        
        // Karten-Klick Event
        map.on('click', async function(e) {
            const lat = e.latlng.lat;
            const lon = e.latlng.lng;
            
            // Alten Marker entfernen
            if (currentMarker) {
                map.removeLayer(currentMarker);
            }
            
            // Neuen Marker setzen
            currentMarker = L.marker([lat, lon], {
                icon: L.icon({
                    iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
                    shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',
                    iconSize: [25, 41],
                    iconAnchor: [12, 41],
                    popupAnchor: [1, -34],
                    shadowSize: [41, 41]
                })
            }).addTo(map);
            
            // Info-Panel mit Ladehinweis aktualisieren
            const infoPanel = document.getElementById('infoPanel');
            infoPanel.innerHTML = `
                <h2>üéÆ Karlscraft Koordinaten</h2>
                <div class="real-coords">
                    <strong>üìç Echte Koordinaten:</strong><br>
                    Breite: ${lat.toFixed(6)}¬∞<br>
                    L√§nge: ${lon.toFixed(6)}¬∞<br>
                    H√∂he: <span class="elevation-loading">Wird geladen...</span>
                </div>
                <div class="minecraft-coords">
                    <strong>‚õèÔ∏è Minecraft Koordinaten:</strong><br>
                    Berechne mit Vincenty...
                </div>
            `;
            
            // Minecraft-Koordinaten berechnen
            const mc = await convertToMinecraft(lat, lon);
            
            if (!mc) {
                infoPanel.innerHTML = `
                    <h2>üéÆ Karlscraft Koordinaten</h2>
                    <div class="warning">‚ö†Ô∏è Fehler bei der Berechnung!</div>
                `;
                return;
            }
            
            // Info-Panel aktualisieren
            let elevationText = mc.elevation !== null ? `${mc.elevation.toFixed(1)} m` : 'Nicht verf√ºgbar';
            let yText = mc.y !== null ? `${mc.y}` : 'Nicht verf√ºgbar';
            let yClass = '';
            let warning = '';
            
            if (mc.y !== null && mc.y > 255) {
                yClass = 'y-limit-exceeded';
                warning = '<div class="warning">‚ö†Ô∏è WARNUNG: Y-Koordinate √ºber 255!<br>Baulimit √ºberschritten!</div>';
            }
            
            const minecraftDistance = Math.round(Math.sqrt(mc.x*mc.x + mc.z*mc.z));
            
            infoPanel.innerHTML = `
                <h2>üéÆ Karlscraft Koordinaten</h2>
                <div class="real-coords">
                    <strong>üìç Echte Koordinaten:</strong><br>
                    Breite: ${lat.toFixed(6)}¬∞<br>
                    L√§nge: ${lon.toFixed(6)}¬∞<br>
                    H√∂he: ${elevationText} √ºber NN
                </div>
                <div class="minecraft-coords">
                    <strong>‚õèÔ∏è Minecraft Koordinaten:</strong><br>
                    X: ${mc.x}<br>
                    Y: <span class="${yClass}">${yText}</span><br>
                    Z: ${mc.z}
                </div>
                ${warning}
                <p style="margin-top: 15px; color: #7f8c8d; font-size: 12px;">
                    <strong>Distanz vom Nullpunkt:</strong><br>
                    ${minecraftDistance} Bl√∂cke<br>
                    (${mc.distance.toFixed(2)} m real)
                </p>
            `;
        });
    </script>
</body>
</html>
